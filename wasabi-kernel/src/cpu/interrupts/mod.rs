//! kernelutilities/handlers for interrupts

// docs are hiden, because this module "only" contains autogenerated interrupt handlers
// "auto generated" here means created by macros.
// there is also [default_handler::init_all_default_interrupt_handlers] which is not
// autogenerated, but only sets them as the handlers in the IDT.
mod default_handlers;

use core::{cell::UnsafeCell, fmt};

#[allow(unused_imports)]
use log::{debug, error, info, warn};
use shared_derive::U8Enum;

use super::apic::Apic;
use crate::{
    cpu::gdt::{CONTEXT_SWITCH_IST_INDEX, DOUBLE_FAULT_IST_INDEX, PAGE_FAULT_IST_INDEX},
    locals,
    mem::page_table::PageTable,
    prelude::ReadWriteCell,
    task::context_switch_handler,
};
use interrupt_fn_builder::{exception_fn, exception_page_fault_fn};
use shared::sync::lockcell::{LockCell, RWLockCell};
use thiserror::Error;
use x86_64::{
    registers::control::Cr2,
    structures::{
        idt::{InterruptDescriptorTable, InterruptStackFrame},
        paging::{Translate, mapper::TranslateResult},
    },
};

// TODO change interrupts to also store all registers + InterruptStackFrame
//  this means that I will no longer be able to rely on x86-interrupt and will
//  have to implement the handler using a naked function.......
//  Yay, I get to write assembly again and will have to figure out how to
//  best create and pass structs.
//  Also I will need to figure out what registers I need to store.
//  I assume all of them if I want to implement a task switching system, but I
//  have no idea what all of them are.
//  I assume in addition to the general purpose registers I will have to get
//  floating point and simd. Is there more? How do I detect which simd registers
//  exist? This is super annoying......

/// The function type used for interrupt handlers
pub type InterruptFn =
    fn(interrupt_vector: InterruptVector, stack_frame: InterruptStackFrame) -> Result<(), ()>;

/// An interrupt vector is 8bits so there are `256` total interrupts.
/// However the first `32` are for exceptions that are handled in a special
/// way, therefore we only allow `256 - 32 = 224` handlers.
pub const MAX_INTERRUPT_HANDLER_COUNT: usize = 256 - 32;

/// A struct containing all state related to handling interrupts by the kernel
pub struct InterruptHandlerState {
    /// RW locked array holding all interrupt handlers or None.
    ///
    /// The index into the array is `interrupt_vector - 32`. We don't store
    /// handlers for the first 32 interrupts, as those are used as exceptions handlers
    /// by the CPU and have a different function signature.
    handlers: ReadWriteCell<[Option<InterruptFn>; MAX_INTERRUPT_HANDLER_COUNT]>,
    /// The kernel idt used by a processor
    idt: UnsafeCell<InterruptDescriptorTable>,
}

impl InterruptHandlerState {
    /// Creates a new [InterruptHandlerState]
    ///
    /// containing memory for an IDT and the handler function pointers
    pub const fn new() -> Self {
        InterruptHandlerState {
            handlers: ReadWriteCell::new([None; MAX_INTERRUPT_HANDLER_COUNT]),
            idt: UnsafeCell::new(InterruptDescriptorTable::new()),
        }
    }

    fn idt(&self) -> &InterruptDescriptorTable {
        // Saftey: the only time this is accessed as mutable is during `interrupts::init`
        // which does not alias this
        unsafe { &*self.idt.get() }
    }

    /// Initializes IDT
    ///
    /// # Safety
    ///
    /// `&self` must be fullfill all guarantees of `&mut self`
    unsafe fn init(&self) {
        // Saftey: see [Self::init]
        let idt = unsafe { &mut *self.idt.get() };

        // init_all_default must be called first or otherwise, this will
        // override any interrupts
        default_handlers::init_all_default_interrupt_handlers(idt);
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt.non_maskable_interrupt
            .set_handler_fn(crate::panic::nmi_panic_handler);

        // we have to manually set double_fault and page fault in order to set the stack index
        // Safetey:
        // tss initialization allocates stacks for double/page fault as well as context switch
        unsafe {
            idt.double_fault
                .set_handler_fn(default_handlers::double_fault)
                .set_stack_index(DOUBLE_FAULT_IST_INDEX);

            idt.page_fault
                .set_handler_fn(page_fault_handler)
                .set_stack_index(PAGE_FAULT_IST_INDEX);

            idt[InterruptVector::ContextSwitch as u8]
                .set_handler_fn(context_switch_handler)
                .set_stack_index(CONTEXT_SWITCH_IST_INDEX);
        }

        register_interrupt_handler(InterruptVector::Nop, |_, _| Ok(()))
            .expect("Failed to register Nop interrupt handler");
    }
}

/// setup idt and enable interrupts
///
/// # Safety
///
/// must be called during processor startup, after logging and core_locals
/// are initialized
pub unsafe fn init() {
    info!("Load IDT");

    let interrupt_state = &locals!().interrupt_state;
    unsafe {
        // we have uniuq access here, becasue we are in a processor startup
        interrupt_state.init();
    }

    interrupt_state.idt().load();

    unsafe {
        debug!("interrupts are enabled starting now");
        // safety: this enables interrupts for the kernel after necessary
        // setup is finished
        locals!().enable_interrupts();

        assert!(locals!().interrupts_enabled());
    }
}

/// The different interrupt vectors used by the kernel
// NOTE: all values must be >= 32
#[derive(U8Enum, Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum InterruptVector {
    /// Interrupt used by the task system to switch between tasks
    ContextSwitch = 32,
    /// Spurious APIC interrupt
    // for some older processors the lower 4 bits must be 1 on spurious interrupts,
    // 63 is the lowest number >=32 matching this condition
    Spurious = 63,

    /// No Op handler
    ///
    /// does nothing
    Nop = 254,

    /// Interrupt used for tests
    Test = 255,
    // TODO add Other variant
}

impl fmt::Display for InterruptVector {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!("{:?}({})", self, *self as u8))
    }
}

#[derive(Error, Debug, PartialEq, Eq, Clone)]
#[allow(missing_docs)]
pub enum InterruptRegistrationError {
    #[error("Interrupt vector({0}) was already registered")]
    InterruptVectorInUse(InterruptVector),
    #[error("Interrupt vector({0}) was never registered")]
    InterruptVectorNotRegistered(InterruptVector),
    #[error("No Interrupt vector registered")]
    NoRegisteredVector,
}

/// registers a new `handler` for the interrupt `vector`.
///
/// Returns the old hanlder if a handler is already
/// registered for this `vector`
pub fn register_interrupt_handler(
    vector: InterruptVector,
    handler: InterruptFn,
) -> Option<InterruptFn> {
    check_interrupt_vector(vector);

    // TODO Fail on special use InterruptVectors, e.g. TaskSystem's ContextSwitch

    let mut handler_guard = locals!().interrupt_state.handlers.lock();
    let handlers = &mut handler_guard;

    let index = (vector as u8 - 32) as usize;

    let old = handlers[index];

    handlers[index] = Some(handler);

    old
}

/// unregisteres the previously registered handler for `vector`.
///
/// Fails with [InterruptRegistrationError::InterruptVectorNotRegistered] if no handler
/// was registered for the handler
pub fn unregister_interrupt_handler(
    vector: InterruptVector,
) -> Result<InterruptFn, InterruptRegistrationError> {
    check_interrupt_vector(vector);
    let mut handler_guard = locals!().interrupt_state.handlers.lock();
    let handlers = &mut handler_guard;

    let index = (vector as u8 - 32) as usize;

    if let Some(handler) = handlers[index] {
        Ok(handler)
    } else {
        Err(InterruptRegistrationError::InterruptVectorNotRegistered(
            vector,
        ))
    }
}

/// returns the registered handler for `vector` or `None` if none was registered
#[inline]
pub fn get_interrupt_handler(vector: InterruptVector) -> Option<InterruptFn> {
    check_interrupt_vector(vector);

    let vector = vector as u8;
    let index = (vector - 32) as usize;
    locals!().interrupt_state.handlers.read()[index]
}

/// asserts that the `vector` is a valid interrupt handler.
///
/// ```
/// # let vector = 35;
/// assert!(vector >= 32 && vector <= 255);
/// ```
fn check_interrupt_vector(vector: InterruptVector) {
    // TODO InterruptVector is enum so I should be able to check all
    //  variances at compile time
    assert!(
        vector as u8 >= 32,
        "interrupt handler called with invalid vector of {vector}"
    );
}

exception_fn!(breakpoint_handler, stack_frame, {
    warn!("breakpoint hit at\n{stack_frame:#?}");
});

/// the number of pages for the double fault exception stack
///
/// DF uses a separate stack, in case DF was caused by a stack overflow
pub const DOUBLE_FAULT_STACK_PAGE_COUNT: u64 = 16;

/// the number of pages for the page fault exception stack
///
/// PF uses a separate stack, in case PF was caused by a stack overflow
pub const PAGE_FAULT_STACK_PAGE_COUNT: u64 = 16;

/// generic interrupt handler, that is called for any interrupt handler with
/// `interrupt_vector >= 32`.
fn interrupt_handler(interrupt_vector: u8, int_stack_frame: InterruptStackFrame) {
    // NOTE: for the exceptions this is autogenerated. However for general purpose interrupts
    // I want to move this from the macro-generated function into here, so this is not duplicated
    // in the assembly
    let _guard = crate::locals!().inc_interrupt();

    let interrupt_vector = match InterruptVector::try_from(interrupt_vector) {
        Ok(v) => v,
        Err(_) => panic!("Interrupt {interrupt_vector} not defined: \n{int_stack_frame:#?}"),
    };

    let handler = get_interrupt_handler(interrupt_vector);

    if let Some(handler) = handler {
        match handler(interrupt_vector, int_stack_frame) {
            Ok(_) => unsafe {
                // TODO only eoi on fixed delivery mode.
                // if the delivery mode is  NMI, SMI, INIT, ExtINT, the start-up, or INIT-Deassert
                // we shouldn't eoi. Not sure if we ever handle those types of interrupts

                if interrupt_vector != InterruptVector::Spurious {
                    // Safety: we sucessfully handled an interrupt, so we can eoi
                    Apic::eoi();
                }
            },
            Err(()) => {
                panic!("interrupt handler for {interrupt_vector} failed.");
            }
        }
    } else {
        panic!("Interrupt {interrupt_vector} not handled: \n{int_stack_frame:#?}");
    }
}

exception_page_fault_fn!(pub(super) page_fault_handler, stack_frame, page_fault, {
    use shared::sync::lockcell::LockCellInternal;
    let page_table = unsafe {
        // TODO this is not save, but otherwise we might deadlock and I only want to read right
        // now, so this should be fine :shrug:
        PageTable::get_for_kernel().lockcell.get_mut().assume_init_mut()
    };
    let vaddr = Cr2::read().expect("Cr2 is not a valid addr");
    log::info!("cr2: {vaddr:p}");
    if let TranslateResult::Mapped { frame, offset, flags } = page_table.translate(vaddr) {
        log::warn!(
            "PAGE FAULT: {:p}: frame: {:?}, offset: {:#X}, flags: {:?}",
            vaddr,
            frame,
            offset,
            flags
        );
    }
    panic!(
        "PAGE FAULT:\nAccessed Address: {vaddr:p}\nError code: {page_fault:?}\n{stack_frame:#?}"
    );
});

#[cfg(feature = "test")]
mod test {
    use core::hint::black_box;

    use testing::{KernelTestError, description::TestExitState, kernel_test};

    /// This test was added to proteced against a too small stack for
    /// the page fault handler
    #[kernel_test(expected_exit: TestExitState::Panic)]
    fn test_page_fault_panic() -> Result<(), KernelTestError> {
        let fake_ptr = 0 as *const u64;
        unsafe {
            let invalid = *fake_ptr;
            black_box(invalid);
        }

        Ok(())
    }
}
